=====================
Лабораторна робота №3
=====================
**Завдання:**
* Изучить принципы работы со списками в ядре, потоки и механизмы синхронизации

* Написать модуль ядра, который:

    - содержит переменную

    - запускает M потоков на одновременное выполнение

    - каждый поток инкрементирует переменную N раз, кладет значение переменной в список и завершается

    - при выгрузке модуль выводит значение переменной и содержимое списка
использовать параметры модуля для задания инкремента N и количества потоков M (в коде параметры должны называться осмысленно)

    - для переменной, списка, потоков использовать динамическую аллокацию. Переменную передавать в поток по ссылке аргументом

* Проверить на x86 и BBXM. Продемонстрировать, что без синхронизации итоговое значение глобальной переменной неправильное

* Реализовать функции lock() и unlock() с использованием атомарных операций ядра (atomic.h, отличается в зависимости от архитектуры). Предусмотреть возможность работы как на x86, так и на BBXM (например, можно использовать макроопределения ядра для условной компиляции). Продемонстрировать работоспособность.

* Защитить доступ к шареным элементам (список тоже к ним относится). Продемонстрировать правильность работы на x86 и BBXM

* Необходимо учитывать и корректно отрабатывать возможные ошибки. Например, kmalloc может не выделить память. При ошибке ресурсы должны деаллоцироваться в порядке обратном аллокации (можно использовать goto или битовое поле с флагами), а в лог ядра выводится ошибка (KERN_ERR или другой подобный уровень лога, но не KERN_INFO)

* Все промежуточные результаты описать и включить в отчет

