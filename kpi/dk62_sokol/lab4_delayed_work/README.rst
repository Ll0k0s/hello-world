=====================
Лабораторна робота №3
=====================
**Завдання:**

- За основу можно взять код из предыдущей лабораторной

- Изучить особенности работы таймеров и workqueue

- Реализовать два потока, запустить таймер и ворк в shared workqueue

- При срабатывании таймера проверить текущее значение jiffies, если оно кратно 11 – остановить поток 1, иначе – таймер должен перезапустить себя через 17 jiffies

- Внутри ворка проверить текущее значение jiffies, если оно кратно 11 – остановить поток 2, иначе – ворк должен уснуть на 17 jiffies и перезапустить себя

- Добавить два связных списка, в которые аллоцировать и добавлять элементы со значениями jiffies, которые не привели к завершению потоков 1 и 2. Получается связь таймер - список 1 
- поток 1. И ворк - список 2 - поток 2

- При выходе из потоков распечатывать списки

- Внутри ворка и таймера использовать правильные аллокации для новых элементов списка, правильную синхронизацию работы со списком

- Предусмотреть, что пользователь может выгрузить модуль до отработки всех таймеров и ворков

--------------------

**Коротко про workqueue:**

- workueue є дуже схожими з tasklet. 

- Вони можуть служити для обробки переривань, 

- виконуються в контексті kernel-процеса, тому вони не обов'язково можуть бути атомарними 

- можуть використовувати функції для синхронізації

- такі функції можуть спати
 
**Коротко про таймери:**



--------------------

**Хід роботи:**

- Для початку було побудовано 2 зв'язані списки, тому для цього, як і в минулій лабораторній роботі їх було ініціалізово:

.. code-block::

	INIT_LIST_HEAD(&res_list1.list);
	INIT_LIST_HEAD(&res_list2.list);

- Для роботи з цими списками було використано структуру result:

.. code-block::

	struct result {
		struct list_head list;
		long int num;
	};

	struct result res_list1, res_list2;
	struct result *work_ptr = NULL;
	struct result *timer_ptr = NULL;

- Далі необхідно створити 2 потоки та виділити для них пам'ять. Перший потік необхідний для підтримки таймера, а другий для - workueue.

- Для створення таймера використовується функція timer_setup(), який має 3 аргументи(відповідний таймер; функція, яка виконується при закінченні таймера; будь-які прапорці ``TIMER_``). Маються такі прапорці:

  * TIMER_DEFERRABLE: таймер, що відкладається, буде працювати нормально, коли система зайнята, але не призведе до того, що процесор вийде з режиму очікування просто для його обслуговування; натомість таймер буде обслуговуватися, коли процесор врешті-решт прокинеться з наступним таймером, який не відкладається.

  * TIMER_IRQSAFE: Таймер irqsafe виконується з відключеним IRQ, і безпечно чекає завершення запущеного примірника від обробників IRQ, наприклад, викликавши del_timer_sync ().
 
  * Примітка: Виконання відключеного виклику irq - це особливий випадок, коли виникає проблема блокування робочих черг. Він не призначений для виконання випадкових лайнів із відключеннями переривань. Зловживання контролюються!

  * TIMER_PINNED: На закріплений таймер, не впливатиме ніяка евристика розміщення таймера (наприклад, NOHZ) і завжди закінчується в процесорі, на якому був задіяний таймер.

  * Примітка: Оскільки замикання таймерів може перенести таймер з центрального процесора на інший, закріплені таймери не гарантовано залишаються на початково вибраному процесорі. Вони переміщуються до центрального процесора, на який функція enqueue викликається через mod_timer () або add_timer (). Якщо таймер слід розмістити на певному процесорі, тоді слід використовувати add_timer_on ().

11



timer_setup(&timer, &timer_func, 0);

.. code-block::
.. code-block::
.. code-block::
.. code-block::
.. code-block::
.. code-block::
.. code-block::
.. code-block::
.. code-block::
.. code-block::
.. code-block::
.. code-block::
.. code-block::



--------------------

**Висновок:**



