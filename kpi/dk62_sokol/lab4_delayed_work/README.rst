=====================
Лабораторна робота №3
=====================
**Завдання:**

- За основу можно взять код из предыдущей лабораторной

- Изучить особенности работы таймеров и workqueue

- Реализовать два потока, запустить таймер и ворк в shared workqueue

- При срабатывании таймера проверить текущее значение jiffies, если оно кратно 11 – остановить поток 1, иначе – таймер должен перезапустить себя через 17 jiffies

- Внутри ворка проверить текущее значение jiffies, если оно кратно 11 – остановить поток 2, иначе – ворк должен уснуть на 17 jiffies и перезапустить себя

- Добавить два связных списка, в которые аллоцировать и добавлять элементы со значениями jiffies, которые не привели к завершению потоков 1 и 2. Получается связь таймер - список 1 
- поток 1. И ворк - список 2 - поток 2

- При выходе из потоков распечатывать списки

- Внутри ворка и таймера использовать правильные аллокации для новых элементов списка, правильную синхронизацию работы со списком

- Предусмотреть, что пользователь может выгрузить модуль до отработки всех таймеров и ворков

--------------------

**Коротко про workqueue:**

- workueue є дуже схожими з tasklet. 

- Вони можуть служити для обробки переривань, 

- виконуються в контексті kernel-процеса, тому вони не обов'язково можуть бути атомарними 

- можуть використовувати функції для синхронізації

- такі функції можуть спати
 
**Коротко про таймери:**



--------------------

**Хід роботи:**

- Для початку було побудовано 2 зв'язані списки, тому для цього, як і в минулій лабораторній роботі їх було ініціалізово:

.. code-block::

	INIT_LIST_HEAD(&res_list1.list);
	INIT_LIST_HEAD(&res_list2.list);

- Для роботи з цими списками було використано структуру result:

.. code-block::

	struct result {
		struct list_head list;
		long int num;
	};

	struct result res_list1, res_list2;
	struct result *work_ptr = NULL;
	struct result *timer_ptr = NULL;

- Далі необхідно створити 2 потоки та виділити для них пам'ять. Перший потік необхідний для підтримки таймера, а другий для - workueue.

- Для створення таймера використовується функція timer_setup(), який має 3 аргументи(відповідний таймер; функція, яка виконується при закінченні таймера; будь-які прапорці ``TIMER_``)

timer_setup(&timer, &timer_func, 0);

.. code-block::
.. code-block::
.. code-block::
.. code-block::
.. code-block::
.. code-block::
.. code-block::
.. code-block::
.. code-block::
.. code-block::
.. code-block::
.. code-block::
.. code-block::



--------------------

**Висновок:**



